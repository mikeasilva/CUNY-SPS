---
title: "CUNY SPS DATA 605 Final"
author: "Mike Silva"
date: "`r Sys.Date()`"
output:
  prettydoc::html_pretty:
    theme: architect
    highlight: github
---

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(MASS)
library(Matrix)
library(knitr)
library(matlib)
library(dplyr)
library(ggplot2)
library(tidyr)
library(kableExtra)
```

## Problem 1

Using R, generate a random variable X that has 10,000 random uniform numbers from 1 to N, where N can be any number of your choosing greater than or equal to 6. Then generate a random variable Y that has 10,000 random normal numbers with a mean of $\mu=\sigma=\frac{N+1}{2}$.

```{r, echo=TRUE, eval=TRUE, comment=NA}
set.seed(12345)
N <- 10
n <- 10000
mu <- sigma <- (N + 1)/2
df <- data.frame(X = runif(n, min=1, max=N), 
                 Y = rnorm(n, mean=mu, sd=sigma))
summary(df$X)
summary(df$Y)
```

### Probability

Calculate as a minimum the below probabilities a through c. Assume the small letter "x" is estimated as the median of the X variable, and the small letter "y" is estimated as the 1st quartile of the Y variable. Interpret the meaning of all probabilities.

```{r echo=TRUE, eval=TRUE}
x <- median(df$X)
y <- as.numeric(quantile(df$Y)["25%"])
```

small letter "x" is `r x` and small letter "y" is `r y`.

a. $P(X>x | X>y)$ 

```{r echo=TRUE, eval=TRUE}
P_a_and_b <- df %>%
  filter(X > x,
         X > y) %>%
  nrow() / n

P_b <- df %>%
  filter(X > y) %>%
  nrow() / n

problem_1a <- P_a_and_b / P_b
```

**The probablity of a random number uniformly ranging from 1 to `r N` being greater than `r x` given that it is greater than `r y` is `r problem_1a`**

b. $P(X>x, Y>y)$ 

```{r echo=TRUE, eval=TRUE}
problem_1b <- df %>%
  filter(X > x,
         Y > y) %>%
  nrow() / n
```

**The probablity of a random number uniformly ranging from 1 to `r N` being greater than `r x` and a random normally distributed number with a mean and standard deviation of `r mu` being greater than `r y` is `r problem_1b`**

c. $P(X<x | X>y)$

```{r echo=TRUE, eval=TRUE}
P_a_and_b <- df %>%
  filter(X < x,
         X > y) %>%
  nrow() / n

P_b <- df %>%
  filter(X > y) %>%
  nrow() / n

problem_1c <- P_a_and_b / P_b
```

**The probablity of a random number uniformly ranging from 1 to `r N` being less than `r x` given that it is greater than `r y` is `r problem_1c`**

Investigate whether P(X>x and Y>y)=P(X>x)P(Y>y) by building a table and evaluating the marginal and joint probabilities.

```{r echo=TRUE, eval=TRUE}
# Create Joint Probabilities
temp <- df %>%
  mutate(A = ifelse(X > x, " X greater than x", " X not greater than x"),
         B = ifelse(Y > y, " Y greater than y", " Y not greater than y")) %>%
  group_by(A, B) %>%
  summarise(count = n()) %>%
  mutate(probability = count / n)

# Create Marginal Probabilities
temp <- temp %>%
  ungroup() %>%
  group_by(A) %>%
  summarise(count = sum(count),
            probability = sum(probability)) %>%
  mutate(B = "Total") %>%
  bind_rows(temp)

temp <- temp %>%
  ungroup() %>%
  group_by(B) %>%
  summarise(count = sum(count),
            probability = sum(probability)) %>%
  mutate(A = "Total") %>%
  bind_rows(temp)

# Create Table
temp %>%
  select(-count) %>%
  spread(A, probability) %>%
  rename(" " = B) %>%
  kable() %>%
  kable_styling()
```

**P(X>x and Y>y) is `r temp[temp$A == " X greater than x" & temp$B == " Y greater than y",]$probability`. P(X>x)P(Y>y) is `r temp[temp$A == " X greater than x" & temp$B == "Total",]$probability` $\times$ `r temp[temp$A == "Total" & temp$B == " Y greater than y",]$probability` which is `r temp[temp$A == " X greater than x" & temp$B == "Total",]$probability * temp[temp$A == "Total" & temp$B == " Y greater than y",]$probability`.  They are not the same.**

Check to see if independence holds by using Fisher's Exact Test and the Chi Square Test. What is the difference between the two? Which is most appropriate?

```{r, echo=TRUE, eval=TRUE, comment=NA}
count_data <- temp %>%
  filter(A != "Total",
         B != "Total") %>%
  select(-probability) %>%
  spread(A, count) %>%
  as.data.frame()

row.names(count_data) <- count_data$B

count_data <- count_data %>%
  select(-B) %>%
  as.matrix() 


fisher.test(count_data)
```

```{r, echo=TRUE, eval=TRUE, comment=NA}
chisq.test(count_data)
```

**Fisher's Exact Test is for is used when you have small cell sizes (less than 5).  The Chi Square Test is used when the cell sizes are large.  It would be appropriate in this case.**

## Problem 2

You are to register for Kaggle.com (free) and compete in the House Prices: Advanced Regression Techniques competition. https://www.kaggle.com/c/house-prices-advanced-regression-techniques. I want you to do the following.

```{r, echo=TRUE, eval=TRUE}
kaggle <- read.csv("Kaggle_House_Prices/train.csv") %>%
  filter(GrLivArea < 4000) %>% # Removing outliers per http://jse.amstat.org/v19n3/decock.pdf
  # Filling in missing values with zeros where it makes sense
  mutate(BedroomAbvGr = replace_na(BedroomAbvGr, 0),
         BsmtFullBath = replace_na(BsmtFullBath, 0),
         BsmtHalfBath = replace_na(BsmtHalfBath, 0),
         BsmtUnfSF = replace_na(BsmtUnfSF, 0),
         EnclosedPorch = replace_na(EnclosedPorch, 0),
         Fireplaces = replace_na(Fireplaces, 0),
         GarageArea = replace_na(GarageArea, 0),
         GarageCars = replace_na(GarageCars, 0),
         HalfBath = replace_na(HalfBath, 0),
         KitchenAbvGr = replace_na(KitchenAbvGr, 0),
         LotFrontage = replace_na(LotFrontage, 0),
         OpenPorchSF = replace_na(OpenPorchSF, 0),
         PoolArea = replace_na(PoolArea, 0),
         ScreenPorch = replace_na(ScreenPorch, 0),
         TotRmsAbvGrd = replace_na(TotRmsAbvGrd, 0),
         WoodDeckSF = replace_na(WoodDeckSF, 0))
```

There are some numerical features that are really categories that will need to be cleaned up

```{r}
clean_MSSubClass <- function(x){
  return(paste0("SC", as.character(x)))
}

clean_MoSold <- function(x){
  if(x > 9){return(as.character(x))}
  else{
    return(paste0("0", as.character(x)))
  }
}

kaggle <- kaggle %>%
  rowwise() %>%
  mutate(MSSubClass = clean_MSSubClass(MSSubClass)) %>%
  mutate(MoSold = clean_MoSold(MoSold)) %>%
  ungroup() %>%
  mutate(MSSubClass = as.factor(MSSubClass),
         MoSold = as.factor(MoSold)) %>%
  as.data.frame()
```

### Descriptive and Inferential Statistics

Provide univariate descriptive statistics and appropriate plots for the training data set. 

```{r echo=FALSE, eval=TRUE, results='asis', warning=FALSE}
for (variable in  names(kaggle)){
  cat(paste("<h4>", variable, "</h4>"))
  
  d <- kaggle[,names(kaggle) == variable]
  
  if(is.factor(d)){
    p <- ggplot(kaggle, aes_string(variable)) + 
      geom_bar() + 
      theme(axis.text.x = element_text(angle = 45, hjust = 1))
    
    d_table <- kaggle %>%
      group_by(.dots = variable) %>%
      summarise(count = n()) %>%
      kable() %>%
      kable_styling()
  } else {
    p <- ggplot(kaggle, aes_string(variable)) + 
      geom_density()
    q <- quantile(d, na.rm = TRUE)
    d_table <- data.frame(Min = min(d, na.rm = TRUE),
                          First = q[2],
                          Median = median(d, na.rm = TRUE), 
                          Mean = mean(d, na.rm = TRUE),
                          Third = q[4],
                          Max = max(d, na.rm = TRUE)) %>%
      rename("First Quartile" = First,
             "Third Quartile" = Third) %>%
      gather(Measure, Value) %>%
      kable() %>%
      kable_styling()
  }
  print(p)
  print(d_table)
}
```

Provide a scatterplot matrix for at least two of the independent variables and the dependent variable. 

```{r, echo=TRUE}
kaggle %>%
  select(TotalBsmtSF, GrLivArea, YearBuilt, SalePrice) %>%
  pairs()
```

Derive a correlation matrix for any three quantitative variables in the dataset.

```{r, echo=TRUE}
correlation_matrix <- kaggle %>%
  select(TotalBsmtSF, GrLivArea, YearBuilt) %>%
  cor() %>%
  as.matrix()

correlation_matrix %>%
  kable() %>%
  kable_styling()
```

Test the hypothesis that the correlations between each pairwise set of variables is 0 and provide an 80% confidence interval. 

```{r, results="asis", tidy=TRUE}
zero_vars <- c()

variables <- kaggle %>%
  select(-SalePrice) %>%
  names()

cat("<table><thead><tr><th>Variable</th><th>Correlation</th><th>Equal to Zero</th></tr></thread><tbody>")

for(variable in variables){
  d <- kaggle[,names(kaggle) == variable]
  if(is.numeric(d)){
    results <- cor.test(kaggle$SalePrice, d, conf.level = 0.8)
    if(0 > results$conf.int[1] & results$conf.int[2] > 0){
      hypothesis_test_results <- "Yes"
      zero_vars <- c(zero_vars, variable)
    } else {
      hypothesis_test_results <- "No"
    }
    cat(paste("<tr><td>",variable,"</td><td>", cor(kaggle$SalePrice, d), "</td><td>", hypothesis_test_results, "</td>"))
  }
}
cat("</tbody></table>")
```

Discuss the meaning of your analysis. Would you be worried about familywise error? Why or why not?

**There are `r length(zero_vars)` variables that have no correlation with the sale price.  I would be worried be woried about family-wise error because I just ran `r length(variable)` hypothesis tests.  The family-wise error rate would be: ${FWER} = 1 - (1 - .2)^`r length(zero_vars)` = 1 - `r .8 ^ length(zero_vars)` = `r 1 - (.8^ length(zero_vars))`$.  This means there is a high probability of committing a Type I error.**

### Linear Algebra and Correlation

Invert your correlation matrix from above. (This is known as the precision matrix and contains variance inflation factors on the diagonal.) 

```{r}
precision_matrix <- inv(correlation_matrix)

precision_matrix %>%
  kable() %>%
  kable_styling()
```

Multiply the correlation matrix by the precision matrix, and then multiply the precision matrix by the correlation matrix. 

**This will generate the identity matrix.**

```{r}
correlation_matrix %*% precision_matrix %>%
  round() %>%
  kable() %>%
  kable_styling()
```


```{r}
precision_matrix %*% correlation_matrix %>%
  round() %>%
  kable() %>%
  kable_styling()
```

Conduct LU decomposition on the matrix.

```{r}
A <- Matrix::expand(lu(correlation_matrix))

A$L %>%
  as.matrix() %>%
  kable() %>%
  kable_styling()

A$U %>%
  as.matrix() %>%
  kable() %>%
  kable_styling()
```

### Calculus-Based Probability & Statistics

Many times, it makes sense to fit a closed form distribution to data. Select a variable in the Kaggle.com training dataset that is skewed to the right, shift it so that the minimum value is absolutely above zero if necessary. Then load the MASS package and run fitdistr to fit an exponential probability density function. (See https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/fitdistr.html). Find the optimal value of $\lambda$ for this distribution, and then take 1000 samples from this exponential distribution using this value (e.g., rexp(1000, $\lambda$)). Plot a histogram and compare it with a histogram of your original variable. Using the exponential pdf, find the 5th and 95th percentiles using the cumulative distribution function (CDF). Also generate a 95% confidence interval from the empirical data, assuming normality. Finally, provide the empirical 5th percentile and 95th percentile of the data. Discuss.

### Modeling

Build some type of multiple regression model and submit your model to the competition board. Provide your complete model summary and results with analysis. Report your Kaggle.com user name and score.

(http://jse.amstat.org/v19n3/decock.pdf)