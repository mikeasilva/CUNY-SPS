---
title: "DATA 624 Project 1 Part B - Power"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
    toc_depth: 3
    code_folding: "hide"
---


```{r setup, echo=FALSE, cache=FALSE, message=FALSE}
knitr::opts_chunk$set(echo = T, comment = NA, message = F, warning = F)
library(tidyverse)
library(readxl)
library(lubridate)
library(kableExtra)
library(fpp2)
library(forcats)
library(gridExtra)
options(scipen = 999)
```

## Introduction

I am to forecast how much power will be consumed by residential customers in kilowatt hours for the next 12 months.  Data was provided for this project spaning January 1998 until December 2013.  

## Data Exploration

I will begin by reading in the data and ploting the series.

```{r}
kwh <- read_excel("ResidentialCustomerForecastLoad-624.xlsx") %>%
  select(KWH) %>%
  ts(start = decimal_date(date("1998-01-01")), frequency = 12)

autoplot(kwh, main = "Residential Power Usage (KWH)") +
  theme(axis.title = element_blank())
```

```{r}
summary(kwh)
```

We have outliers and missing data.  We will clean them up with `tsclean` from the forcasts package, and replot the data with the ACF and PACF:

```{r}
kwh <- tsclean(kwh)

ggtsplot <- function(ts, title) {
  # A ggplot2 version of tsdisplay(df)
  # Args:
  #    ts (Time-Series): The time series we want to plot
  #    title (str): The title of the graph
  grid.arrange(
    autoplot(ts) +
      ggtitle(title) +
      theme(axis.title = element_blank()),
    grid.arrange(
      ggAcf(ts) + ggtitle(element_blank()),
      ggPacf(ts) + ggtitle(element_blank()), ncol = 2)
    , nrow = 2)
}


ggtsplot(kwh, "Cleaned Residential Power Usage (KWH)")
```

This looks much better.  There is a seasonal component that looks to be additive.  I will need to use a model that captures seasonality.

## Candidate Models

Since the data is highly seasonal, I we will need to use an ARIMA or Holt-Winters model.  Let's fit an models using `auto.arima()` and `hw()` and visualize their projections.  I will use a couple of different parameters with the Holt-Winters model.

```{r}
h <- 12
lambda <- BoxCox.lambda(kwh)
autoplot(kwh) +
  autolayer(hw(kwh, h = h), series = "Holt-Winters") +
  autolayer(hw(kwh, h = h, lambda = lambda), series = "Holt-Winters (Box-Cox Adjusted)") +
  autolayer(hw(kwh, h = h, lambda = lambda, damped = TRUE), series = "Holt-Winters (Damped & Box-Cox Adjusted)") +
  autolayer(forecast(auto.arima(kwh), h = h), series = "ARIMA") +
  facet_wrap(. ~ series, ncol = 2) +
  scale_color_brewer(palette = "Set1") +
  theme(legend.position = "none", axis.title = element_blank())
```

## Residual Analysis

All models do a good job picking up the seasonality.  Let's look at the residuals to see if any of the models should not be used.

### Holt-Winters Model

```{r}
hw_fit <- hw(kwh, h = h)
checkresiduals(hw_fit)
```

### Adjusted Holt-Winters Model

```{r}
adj_hw_fit <- hw(kwh, h = h, lambda = lambda)
checkresiduals(adj_hw_fit)
```

### Damped & Adjusted Holt-Winters Model

```{r}
damp_adj_hw_fit <- hw(kwh, h = h, lambda = lambda, damped = TRUE)
checkresiduals(damp_adj_hw_fit)
```

### ARIMA Model

```{r}
arima_fit <- auto.arima(kwh)
checkresiduals(arima_fit)
```

## Cross Validation

In order to understand how well a model is likely to preform at predicting out of sample data, I will use the `tsCV` function and evaluate the models.  My goal is to minimize the RMSE.  First I will get the errors from the cross validation process, then I will compute the RMSE.

```{r}
get_rmse <- function(e) {
  sqrt(mean(e^2, na.rm=TRUE))
}

hw_error <- tsCV(kwh, hw, h = h)
adj_hw_error <- tsCV(kwh, hw, h = h, lambda = lambda)
damped_adj_hw_error <- tsCV(kwh, hw, h = h, lambda = lambda, damped = TRUE)
arima_errors <- tsCV(kwh, forecast(auto.arima(kwh), h=h), h = h)

data.frame(Model = c("ARIMA", "Holt-Winters", "Adjusted Holt-Winters", "Damped & Adjusted Holt-Winters"),
           RMSE = c(get_rmse(arima_errors[,h]), get_rmse(hw_error[,h]), get_rmse(adj_hw_error[,h]), get_rmse(damped_adj_hw_error[,h]))) %>%
  arrange(RMSE) %>%
  kable() %>%
  kable_styling()
```